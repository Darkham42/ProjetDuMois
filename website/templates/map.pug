div#map.map-main
div#zoom-in.alert.alert-warning.font-weight-bold Zoomez ou lancez une recherche pour commencer

//- This runs on client
script.
	const hasLocation = window.location.hash !== "";

	// Map init
	const map = new mapboxgl.Map({
		container: 'map',
		pitchWithRotate: false,
		dragRotate: false,
		hash: true,
		bounds: [-5.010, 41.212, 10.019, 51.234],
		style: !{JSON.stringify(mapstyle)}
	});

	map.addControl(new mapboxgl.NavigationControl({ showCompass: false }));

	// Geolocate
	const geoloc = new mapboxgl.GeolocateControl({ positionOptions: { enableHighAccuracy: true } });
	map.addControl(geoloc);
	if(!hasLocation) {
		map.on("load", () => geoloc.trigger());
	}

	// Alert for zoom/search
	const zoomAlert = document.getElementById("zoom-in");
	const toggleZoomAlert = () => {
		if(map.getZoom() >= 7) {
			zoomAlert.classList.add("d-none");
		}
		else {
			zoomAlert.classList.remove("d-none");
		}
	};
	toggleZoomAlert();
	map.on("zoom", toggleZoomAlert);

	// Button for KML exports
	class ExportControl {
		onAdd(map) {
			this._map = map;
			this._container = document.createElement('div');
			this._container.className = "mapboxgl-ctrl map-ctrl-btn";
			const osmoseLabels = !{JSON.stringify(osmoseLabels)};
			const [osmoseItem, osmoseClasss] = Object.keys(osmoseLabels)[0].split("_");
			const osmose_params = `item=${osmoseItem}&class=${osmoseClasss}`
			const osmose_bbox = `${map.getBounds()._sw.lng}%2C${map.getBounds()._sw.lat}%2C${map.getBounds()._ne.lng}%2C${map.getBounds()._ne.lat}`
			const osmose_export_url = `#{CONFIG.OSMOSE_URL}/fr/errors.kml?zoom=${map.getZoom()}&${osmose_params}&bbox=${osmose_bbox}`;
			this._container.innerHTML = `<a title="TÃ©lÃ©charger un fichier kml pour contribuer depuis votre smartphone" href="${osmose_export_url}"> ðŸ“² </a>`;
			return this._container;
		}
	}

	map.addControl(new ExportControl(), "top-right");

	// Click on feature
	function getLinks(meta) {
		const elem = meta.elems && meta.elems.length > 0 && meta.elems[0];
		const newElem = meta.new_elems && meta.new_elems.length > 0 && meta.new_elems[0];

		// JOSM commands
		const josmHrefs = [ `#{CONFIG.JOSM_REMOTE_URL}/load_and_zoom?bottom=${meta.minlat}&top=${meta.maxlat}&right=${meta.maxlon}&left=${meta.minlon}${elem && "&select="+elem.type+elem.id || ""}&#{josmParams}` ];
		if(newElem) {
			josmHrefs.push(`#{CONFIG.JOSM_REMOTE_URL}/add_node?lon=${meta.lon}&lat=${meta.lat}&addtags=${encodeURIComponent(newElem.add.map(kv => kv.k+"="+kv.v).join("|"))}`);
		}

		return [
			{ title: "JOSM", hrefs: josmHrefs },
			{ title: "iD", href: `#{CONFIG.OSM_URL}/edit${elem && "?"+elem.type+"="+elem.id || ""}#map=20/${meta.lat}/${meta.lon}&#{idParams}` },
			{ title: "OSM", href: `#{CONFIG.OSM_URL}/${elem && elem.type+"/"+elem.id || ""}#map=18/${meta.lat}/${meta.lon}` },
			{ title: "Osmose", href: `#{CONFIG.OSMOSE_URL}/fr/error/${meta.uuid}` },
			{ title: "Mapillary", href: `#{CONFIG.MAPILLARY_URL}/app/?lat=${meta.lat}&lng=${meta.lon}&z=18` }
		];
	}

	// Mark as done/false in Osmose
	const filteredUuids = [];
	function markOsmose(type, feature, popup) {
		const uuid = feature.properties.uuid;
		return () => {
			// Send to Osmose
			fetch(`#{CONFIG.OSMOSE_URL}/api/0.3beta/issue/${uuid}/${type}`);

			// Hide feature on map
			popup.remove();
			filteredUuids.push(uuid);
			map.setFilter(feature.layer.id, ["!", ["in", ["get", "uuid"], ["literal", filteredUuids]]]);
		};
	}

	function getDescription(feature, popup) {
		const osmoseLabels = !{JSON.stringify(osmoseLabels)};
		const osmoseButtons = !{JSON.stringify(osmoseButtons)};
		const p = feature.properties;
		const resDiv = document.createElement("div");
		resDiv.innerHTML = `<span class="spinner-border text-primary" role="status"></span>`;

		// Retrieve metadata on Osmose API
		fetch(`#{CONFIG.OSMOSE_URL}/api/0.3beta/issue/${p.uuid}`)
		.then(res => res.json())
		.then(meta => {
			const labels = osmoseLabels[`${meta.item}_${meta.class}`] || osmoseLabels[`${meta.item}_all`] || { name: meta.title.auto };
			const buttons = osmoseButtons[`${meta.item}_${meta.class}`] || osmoseButtons[`${meta.item}_all`] || { "done": "RÃ©solu", "false": "Faux positif" };

			const links = getLinks(meta).map(l => {
				const linkDom = document.createElement("a");
				linkDom.appendChild(document.createTextNode(l.title));

				// Simple link
				if(l.href) {
					linkDom.href = l.href;
					linkDom.target = "_blank";
					linkDom.rel = "noopener";
				}
				// Several links (JOSM) : call one, wait 3s, call second...
				else if(l.hrefs) {
					linkDom.classList.add("pdm-link");
					linkDom.addEventListener("click", () => {
						const next = () => {
							const url = l.hrefs.shift();
							if(url) {
								fetch(url).then(() => setTimeout(next, 3000));
							}
						};
						next();
					});
				}

				return linkDom;
			});

			let tags = meta.new_elems && meta.new_elems.length > 0 ? meta.new_elems[0].add.map(kv => kv.k+"="+kv.v).join("\n") : "";
			if(tags.length > 0) {
				tags = `
					<div class="form-group m-0 mb-1">
						<label class="m-0" for="exampleFormControlTextarea1">Attributs</label>
						<textarea class="form-control form-control-sm" rows="3">${tags}</textarea>
					</div>`;
			}

			let subtitle = meta.subtitle.auto;
			if(labels.subtitles) {
				const subtitles = Object.keys(labels.subtitles).filter(s => meta.subtitle.auto.includes(s)).map(s => labels.subtitles[s]);
				if(subtitles.length > 0) { subtitle = subtitles[0]; }
			}

			resDiv.innerHTML = `
				<h5 class="m-0">${labels.name}</h5>
				<p class="m-0 mb-2">${subtitle.replace(/\n/g, "<br />")}</p>
				${tags}`;

			const divLinks = document.createElement("div");
			divLinks.classList.add("text-center");
			links.forEach((l,i) => {
				if(i > 0) { divLinks.appendChild(document.createTextNode(" | ")); }
				divLinks.appendChild(l);
			});
			resDiv.appendChild(divLinks);

			const divButtons = document.createElement("div");
			divButtons.classList.add("btn-group", "btn-group-sm", "btn-block", "mt-1");
			divButtons.role = "group";
			const divButtonDone = document.createElement("button");
			divButtonDone.classList.add("btn", "btn-success");
			divButtonDone.appendChild(document.createTextNode("âœ” "+buttons.done));
			divButtonDone.title = "Marquer cet Ã©lÃ©ment comme \""+buttons.done+"\" si vous avez ajoutÃ©/corrigÃ© le point dans OpenStreetMap";
			divButtonDone.addEventListener("click", markOsmose("done", feature, popup));
			divButtons.appendChild(divButtonDone);
			const divButtonFalse = document.createElement("button");
			divButtonFalse.classList.add("btn", "btn-warning");
			divButtonFalse.appendChild(document.createTextNode("âœ˜ "+buttons.false));
			divButtonFalse.title = "Marquer cet Ã©lÃ©ment comme \""+buttons.false+"\" si le signalement n'est pas valide";
			divButtonFalse.addEventListener("click", markOsmose("false", feature, popup));
			divButtons.appendChild(divButtonFalse);
			resDiv.appendChild(divButtons);
		});

		return resDiv;
	}

	function clickFeature(e) {
		if(!map || !e) { return; }
		const features = map.queryRenderedFeatures(e.point);
		if(!features || features.length === 0) { return; }

		const coordinates = features[0].geometry.coordinates.slice();
		while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
			coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
		}

		const popup = new mapboxgl.Popup().setLngLat(coordinates);
		const description = getDescription(features[0], popup);
		if(typeof description === "string") { popup.setHTML(description); }
		else { popup.setDOMContent(description); }
		popup.addTo(map);
	}

	map.on("click", clickFeature);

//- Generate hover events for each layer dynamically on server
-
	const hoverEvents = mapstyle.layers
		.map(l => l.id)
		.map(id => `map.on('mouseenter', '${id}', () => { map.getCanvas().style.cursor = 'pointer'; });\nmap.on('mouseleave', '${id}', () => { map.getCanvas().style.cursor = ''; });`)
		.join("\n");

script !{hoverEvents}
